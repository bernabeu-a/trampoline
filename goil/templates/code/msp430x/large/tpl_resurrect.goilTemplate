/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * OS data structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME%
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */
%
if OS::RESURRECT then
%
#include <stdbool.h>
#include <stdint.h>

#include "tpl_os_internal_types.h"
#include "tpl_resurrect_kernel.h"
#include "tpl_os_definitions.h"

#include "tpl_os.h"

%

let listEntry := @[]
foreach resurrect_transition in RESURRECT_TRANSITION do
  let key := resurrect_transition::ENTRY
  let listEntryLength := [listEntry length]
  if listEntryLength == 0 then
     let listEntry[key] := key
  else
   foreach item in listEntry do
     if item == key then

    else
      let listEntry[key] := key
    end if
   end foreach
  end if
end foreach

#let listAlarm := @[]
#foreach al in ALARM do
#  let key := al::NAME
#  let listAlarm[key] := INDEX
#end foreach

let listFunc := @[]
foreach resurrect_transition in RESURRECT_TRANSITION do
  if exists resurrect_transition::FUNC then
    foreach item in resurrect_transition::FUNC do
     let key := item::VALUE
     let listFuncLength := [listFunc length]
     if listFuncLength == 0 then
       let listFunc[key] := key
     else
     foreach token in listFunc do
       if token == key then

       else
         let listFunc[key] := key
       end if
     end foreach
     end if
    end foreach
  end if
end foreach
foreach item in listFunc do
%
extern void % !item %(void);
%
end foreach

if OS::ENERGY_PREDICTION then
%
/* Data structure for previous harvesting and prediction */
#if ENERGY_PREDICTOR == SMA

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_energy_buffer, OS_VAR) struct_buffer_power_previous_harvesting = {
/* buffer of %!OS::ENERGY_PREDICTION_S::PREDICTOR_S::SIZE% previous value */ {0},
/* index */                      0,
/* current size */               0
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#endif /* ENERGY_PREDICTOR == SMA */

#if WITH_BET
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_variance_buffer, OS_VAR) struct_variance_buffer = {
/* buffer of 5 previous value */ {0},
/* index */                      0,
/* current size */               0
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif /* WITH_BET */

VAR(tpl_energy, OS_VAR) tpl_resurrect_energy =
{
  &struct_buffer_power_previous_harvesting,    /* buffer of previous harvesting in µW 32bit*/
  0,                                           /* power prediction in µW 32bit */
  0                                            /* error of previous prediction */%
if OS::RESURRECT_S::BET then  
%, 
  0.0,                      /* probability of reaching 1.9V with current energy and prediction */
  0,                        /* flag if come back from sleeping */
  0,                        /* Variance for probability of lossing BET in Q12 */
  &struct_variance_buffer,  /* Buffer for variance computation in Q12 */%
end if%
};
%
end if

if OS::TIMER_ACTIVITY then
%
/* Function for timer, get the time of each activities */

#if WITH_TIMER_ACTIVITY == YES

P2VAR(uint16_t, AUTOMATIC, OS_VAR) ptr_current_time = NULL;

void init_ptr_current_time(){
  ptr_current_time = tpl_kern_resurrect.elected->activity->current_time_activity;
  return;
}
uint16_t time_millisec_activity;

uint16_t time_microsec_activity;

uint8_t isr_timer_activity_count;

void start_timer_activity(){
  /* reset previous measure */
  //time_millisec_activity = 0;
  //time_microsec_activity = 0;
  isr_timer_activity_count = 0;       /* count the numbe rof time we entered the interruption (ie x*6.5536 s) */
  /* Set up timer TA2 with ACLK. ACLK is set to LFXTCLK at start : 32.768 kHz */
  // TA2CCR0 = 0;          /* lock the timer */
  // TA2CTL = TASSEL__ACLK /* ACLK */
  //          | ID__1 /* divide by 1 */
  //          | MC__UP /* Up count */
  //          | TACLR /* Clear counter */;
  // TA2CCTL0 |= CCIE;     /* enable the compare interrupt */
  // TA2CCR0 = 32;         /* start with a 1.007 ms period (33/32768) */

  /* With free running timer */
  TA2CCR0 = 0;              /* lock the timer */
  TA2CTL = TASSEL__SMCLK    /* SMCLK (1 MHz) */
          | ID__2           /* divide by 2 (0.5MHz) */
          | MC__CONTINUOUS  /* Up coutinuous */
          | TACLR;          /* clear counter */
  TA2EX0 = TAIDEX_4;        /* divide by 5 (0.1 MHz) */
  TA2CCTL0 |= CCIE;     /* enable the compare interrupt */       
  return;
}

void stop_timer_activity(){
  // TA2CTL &= ~(MC__UP);          /* stop timer */
  TA2CTL &= ~(MC__CONTINUOUS);  /* stop timer */
  //time_microsec_activity = TA2R<<5; /* multiply by 32 as 1 tick is 1/32768 = 30.5 µs */
  //*ptr_current_time = time_millisec_activity;
  //ptr_current_time++;
  *ptr_current_time = isr_timer_activity_count * 655 + TA2R/100;
  ptr_current_time++;
  return;
}

#define APP_ISR_timer_activity_START_SEC_CODE
#include "tpl_memmap.h"

ISR(timer_activity)
{
  /* interruption every 65535*10 µs */
  //P1OUT ^= BIT0;
  isr_timer_activity_count += 1;
  //time_millisec_activity += 1;
}

#define APP_ISR_timer_activity_STOP_SEC_CODE
#include "tpl_memmap.h"

/*
 * Current time measured for activities
 */

%
foreach resurrect_transition in RESURRECT_TRANSITION
 do
  if exists resurrect_transition::FUNC then
  let nb_activity:= [resurrect_transition::FUNC length]
%
VAR(uint16_t, AUTOMATIC) current_time_slope_step_% !resurrect_transition::NAME% [%!nb_activity%]= {%
loop a from 1 to nb_activity step 1
do
%0%
between
%,%
after
%};
%
end loop
end if
end foreach
%
#endif /* WITH_TIMER_ACTIVITY */
%
end if
#------------------------------------------------------------------------------*
%
#define APP_COMMON_START_SEC_CODE
#include "tpl_memmap.h"


%
foreach resurrect_transition in RESURRECT_TRANSITION do
 if exists resurrect_transition::FUNC then
  foreach item in listEntry do
   if item == resurrect_transition::ENTRY then
    foreach resurrect_transition_func in resurrect_transition::FUNC
      before
%
FUNC(void, OS_APPL_CODE) % !item% (void){
%
if OS::TIMER_ACTIVITY then
tab(5) %init_ptr_current_time();
%
end if
tab(5) %#ifdef BARD
%
tab(5) %initMicrophone();
%
tab(5) %#endif
%
      if exists resurrect_transition::ALARM_RESURRECT then
      foreach resurrect_transition_alarm in resurrect_transition::ALARM_RESURRECT
      do
       foreach al in ALARM_RESURRECT
       do
       if resurrect_transition_alarm::VALUE == al::NAME then
tab(5) %SetNbAlarmActivation(%!al::ALARM%, %!al::NB_ACTIVATION%);
%
tab(5) %SetRelAlarm(%!al::ALARM%, %!al::ALARMTIME%, %!al::CYCLETIME%);
%

      end if
      end foreach
      end foreach
      end if
      do
if OS::TIMER_ACTIVITY then
tab(5)%start_timer_activity();
%
end if
tab(5) !resurrect_transition_func::VALUE%();
%
if OS::TIMER_ACTIVITY then
tab(5)%stop_timer_activity();
%
end if

      after
      if exists resurrect_transition::ALARM_RESURRECT then
      let listAlResurrect := @[]

     foreach item_al in resurrect_transition::ALARM_RESURRECT do
     let key := item_al::VALUE
     let listAlResurrectLength := [listAlResurrect length]
     if listAlResurrectLength == 0 then
       let listAlResurrect[key] := key
     else
     foreach token in listAlResurrect do
       if token == key then
       else
         let listAlResurrect[key] := key
       end if
     end foreach
     end if
    end foreach

#     let list_event_al_res := @[]
#     foreach al_resurrect in ALARM
#     do
#     foreach al in ALARM_RESURRECT do
#       if al_resurrect::VALUE == al::NAME then
#       let key := al::EV
#       let list_event_al_resLength := [list_event_al_res length]
#
#     if list_event_al_resLength == 0 then
#       let list_event_al_res[key] := key
#     else
#     foreach token in list_event_al_res do
#       if token == key then
#       else
#         let list_event_al_res[key] := key
#       end if
#     end foreach
#     end if
#     end if
#     end foreach
#     end foreach


tab(5)%EventMaskType myEventMask;
%
foreach al_resurrect in resurrect_transition::ALARM_RESURRECT
do
tab(5)%WaitEvent(%
foreach al_ev in ALARM
 do
 if exists al_ev::EV then
 foreach item_ev in al_ev::EV do
 !item_ev::VALUE
 end foreach
 end if between% | % after %);
%
end foreach
tab(5)%GetEvent(resurrect, myEventMask);
%
tab(5)%ClearEvent(myEventMask);
%
end foreach
#      foreach resurrect_transition_alarm in resurrect_transition::ALARM_RESURRECT
#      do
#       foreach al in ALARM_RESURRECT
#       do
#       display al
#       display resurrect_transition_alarm
#       if resurrect_transition_alarm::VALUE == al::NAME then
#      tab(5) %WaitEvent(%!al::EV%);
#%
#      tab(5) %ClearEvent(%!al::EV%);
#%
#      tab(5) % CancelAlarm(%!al::ALARM%);
#%
#      end if
#      end foreach
#      end foreach
      end if
tab(5)%TerminateStepResurrect();
}
%

     end foreach
   let listEntry[item] := "NULL"
   end if
  end foreach
 end if
end foreach
%
#define APP_COMMON_STOP_SEC_CODE
#include "tpl_memmap.h"
%
#------------------------------------------------------------------------------*

let listState := @[]
foreach resurrect_state in RESURRECT_STATE do
  let key := resurrect_state::NAME
  let listState[key] := INDEX
end foreach

#------------------------------------------------------------------------------*
let RESURRECT_EVENT := exists RESURRECT_EVENT default (@())


%
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
if OS::TIMER_ACTIVITY then
let list_slope := @! !
foreach slope_res in RESURRECT_SLOPE do
  if [list_slope contains: slope_res::NAME] then

  else
  let list_slope := list_slope + slope_res::NAME
  %CONST (uint16_t, AUTOMATIC) %!slope_res::NAME% = %!slope_res::VALUE%;
 %
  end if
end foreach

let list_slope_time := @! !
foreach slope_time_res in RESURRECT_TIME_SLOPE do
  if [list_slope_time contains: slope_time_res::NAME] then

  else
  let list_slope_time := list_slope_time + slope_time_res::NAME
  %CONST (uint16_t, AUTOMATIC) %!slope_time_res::NAME% = %!slope_time_res::VALUE%;
 %
  end if
end foreach

foreach resurrect_transition in RESURRECT_TRANSITION
  do
  if exists resurrect_transition::SLOPE then
    let nb_activity:= [resurrect_transition::FUNC length]
   %CONST(uint16_t, AUTOMATIC) slope_step_% !resurrect_transition::NAME%[%!nb_activity%] = {
  %
  foreach slope in resurrect_transition::SLOPE do
  %%!slope::VALUE
  between
  %,
  %
  end foreach
  %
};
%
  end if
  if exists resurrect_transition::TIME_SLOPE then
    let nb_activity:= [resurrect_transition::FUNC length]
   %CONST(uint16_t, AUTOMATIC) time_slope_step_% !resurrect_transition::NAME%[%!nb_activity%] = {
  %
  foreach time_slope in resurrect_transition::TIME_SLOPE do
  %%!time_slope::VALUE
  between
  %,
  %
  end foreach
  %
};
%
  end if

end foreach
foreach resurrect_transition in RESURRECT_TRANSITION
 do
  if exists resurrect_transition::FUNC then
  let nb_activity:= [resurrect_transition::FUNC length]
 %CONST(tpl_activity, AUTOMATIC) activity_step_% !resurrect_transition::NAME% = {
  .nb_activity = %!nb_activity%
, .slope = slope_step_%!resurrect_transition::NAME%
, .time_activity = time_slope_step_%!resurrect_transition::NAME%
, .current_time_activity = current_time_slope_step_%!resurrect_transition::NAME%
};

%
 end if
end foreach
end if

foreach resurrect_transition in RESURRECT_TRANSITION
  do
  %
CONST(tpl_step, OS_CONST) step_% !resurrect_transition::NAME% = {
  .energy = % !resurrect_transition::ENERGY%
, .to_state = % !listState[resurrect_transition::TO_STATE]%
, .from_state = % !listState[resurrect_transition::FROM_STATE]%
, .entry_point = % !resurrect_transition::ENTRY%%
if OS::RESURRECT_S::EVENT then%
, .resurrect_event = {%
  if [RESURRECT_EVENT length] == 0 then
  %};%
  else
  foreach res_event in RESURRECT_EVENT
  do
  if exists resurrect_transition::RES_EVENT then
  foreach step_event in resurrect_transition::RES_EVENT do
  if step_event::VALUE == res_event::NAME then
  tab(4)%1%
  else
  tab(4)%0%
  end if
  end foreach
  else
  tab(4)%0%
  end if
  between
  %,%
  after%}%
  end foreach
  end if
  end if
if OS::TIMER_ACTIVITY then
 %
, .activity = &activity_step_% !resurrect_transition::NAME%
%
end if
if OS::RESURRECT_S::BET then
 %
, .delta_v = % !resurrect_transition::DELTA_V%
, .award = % !resurrect_transition::AWARD%
%
end if
%
};
%
end foreach

%
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
let initial_state
let count_initial := 0

foreach resurrect_state in RESURRECT_STATE do
  if resurrect_state::INITIAL_STATE then
    let initial_state := resurrect_state::NAME
    let count_initial := count_initial+1
    if count_initial > 1 then
     error resurrect_state::INITIAL_STATE : "More than one initial state"
    end if
  end if

end foreach

%

/**
 * @internal
 *
 * tpl_kern_resurrect gather informations on the current step and
 * the state
 */

VAR(tpl_kern_resurrect_state, OS_VAR) tpl_kern_resurrect =
{
  NULL,                      /* no elected step   */
  % !listState[initial_state]%,                         /* current state is STATE with INITIAL_STATE = TRUE */%
  if OS::RESURRECT_S::EVENT then
  %
  0,                        /* Events for choice of next step */%
  end if
  if OS::TIMER_ACTIVITY then
  %
  0,                        /* Energy measured when starting the step */%
  end if
  if OS::RESURRECT_S::BET then
  %
  0                         /* Award accumulated with steps */%
  end if
%
};

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%

foreach resurrect_state in RESURRECT_STATE do
      %
CONSTP2CONST(tpl_step, AUTOMATIC, OS_APPL_DATA) step_from_state_%!resurrect_state::NAME% [%!OS::RESURRECT_S::ENERGY_LEVEL%] = {
%
      let transitionListEnergy := @()
      foreach resurrect_transition in RESURRECT_TRANSITION do
        if resurrect_state::NAME == resurrect_transition::FROM_STATE then
         let transitionListEnergy += resurrect_transition
         end if
      end foreach
      sort transitionListEnergy by ENERGY >
      foreach item in transitionListEnergy do
      %&step_% !item::NAME
      between
      %,
%
      after
      if [transitionListEnergy length] < OS::RESURRECT_S::ENERGY_LEVEL then
       let null_count := OS::RESURRECT_S::ENERGY_LEVEL - [transitionListEnergy length]
       loop cnt from 1 to null_count step 1 do
         %
, NULL%
        end loop
      end if
      %};
%
      end foreach
end foreach

foreach resurrect_state in RESURRECT_STATE
before
%
CONSTP2CONST(tpl_step_ref, AUTOMATIC, OS_APPL_DATA) tpl_step_state [RESURRECT_STATE_COUNT] = {
%
do
%step_from_state_%!resurrect_state::NAME
between
%,
%
after
%
};
%
end foreach
%
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
end if
