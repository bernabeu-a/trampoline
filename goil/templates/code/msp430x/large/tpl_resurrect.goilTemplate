/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * OS data structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME%
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */
%
if OS::RESURRECT then 
%
#include <stdbool.h>
#include <stdint.h>

#include "tpl_os_internal_types.h"
#include "tpl_resurrect_kernel.h"
#include "tpl_os_definitions.h"

#include "tpl_os.h"

%

let listEntry := @[]
foreach resurrect_transition in RESURRECT_TRANSITION do
  let key := resurrect_transition::ENTRY
  let listEntryLength := [listEntry length]
  if listEntryLength == 0 then
     let listEntry[key] := key
  else
   foreach item in listEntry do
     if item == key then
   
    else 
      let listEntry[key] := key
    end if
   end foreach
  end if
end foreach

#let listAlarm := @[]
#foreach al in ALARM do
#  let key := al::NAME
#  let listAlarm[key] := INDEX
#end foreach

let listFunc := @[]
foreach resurrect_transition in RESURRECT_TRANSITION do
  if exists resurrect_transition::FUNC then
    foreach item in resurrect_transition::FUNC do
     let key := item::VALUE
     let listFuncLength := [listFunc length]
     if listFuncLength == 0 then
       let listFunc[key] := key
     else
     foreach token in listFunc do
       if token == key then
       
       else
         let listFunc[key] := key
       end if
     end foreach
     end if
    end foreach
  end if
end foreach
foreach item in listFunc do
%
extern void % !item %(void);
%
end foreach

#------------------------------------------------------------------------------*
%
#define APP_COMMON_START_SEC_CODE
#include "tpl_memmap.h"
%
foreach resurrect_transition in RESURRECT_TRANSITION do
 if exists resurrect_transition::FUNC then
  foreach item in listEntry do
   if item == resurrect_transition::ENTRY then
    foreach resurrect_transition_func in resurrect_transition::FUNC
      before
%
FUNC(void, OS_APPL_CODE) % !item% (void){   
%
tab(5) % //initMicrophone();
%
      if exists resurrect_transition::ALARM_RESURRECT then
      foreach resurrect_transition_alarm in resurrect_transition::ALARM_RESURRECT
      do
       foreach al in ALARM_RESURRECT 
       do
       if resurrect_transition_alarm::VALUE == al::NAME then
tab(5) %SetNbAlarmActivation(%!al::ALARM%, %!al::NB_ACTIVATION%);
%
tab(5) %SetRelAlarm(%!al::ALARM%, %!al::ALARMTIME%, %!al::CYCLETIME%);
% 
    
      end if
      end foreach  
      end foreach
      end if
      do
tab(5) !resurrect_transition_func::VALUE%();
%
      after
      if exists resurrect_transition::ALARM_RESURRECT then
      let listAlResurrect := @[]

     foreach item_al in resurrect_transition::ALARM_RESURRECT do
     let key := item_al::VALUE
     let listAlResurrectLength := [listAlResurrect length]
     if listAlResurrectLength == 0 then
       let listAlResurrect[key] := key
     else
     foreach token in listAlResurrect do
       if token == key then
       else
         let listAlResurrect[key] := key
       end if
     end foreach
     end if
    end foreach
     
#     let list_event_al_res := @[]
#     foreach al_resurrect in ALARM 
#     do
#     foreach al in ALARM_RESURRECT do
#       if al_resurrect::VALUE == al::NAME then
#       let key := al::EV
#       let list_event_al_resLength := [list_event_al_res length]
#
#     if list_event_al_resLength == 0 then
#       let list_event_al_res[key] := key
#     else
#     foreach token in list_event_al_res do
#       if token == key then
#       else
#         let list_event_al_res[key] := key
#       end if
#     end foreach
#     end if
#     end if 
#     end foreach
#     end foreach
     

tab(5)%EventMaskType myEventMask;
%
foreach al_resurrect in resurrect_transition::ALARM_RESURRECT 
do
tab(5)%WaitEvent(%
foreach al_ev in ALARM 
 do
 if exists al_ev::EV then
 foreach item_ev in al_ev::EV do
 !item_ev::VALUE 
 end foreach
 end if between% | % after %);
%
end foreach
tab(5)%GetEvent(resurrect, myEventMask);
%
tab(5)%ClearEvent(myEventMask);
%
end foreach
#      foreach resurrect_transition_alarm in resurrect_transition::ALARM_RESURRECT
#      do
#       foreach al in ALARM_RESURRECT
#       do
#       if resurrect_transition_alarm::VALUE == al::NAME then
#      tab(5) %WaitEvent(%!al::EV%);
#%
#      tab(5) %ClearEvent(%!al::EV%);
#%
#      tab(5) % CancelAlarm(%!al::ALARM%);
#%
#      end if
#      end foreach 
#      end foreach
      end if
tab(5)%TerminateStepResurrect();
}
%

     end foreach
   let listEntry[item] := "NULL"
   end if
  end foreach
 end if
end foreach
%
#define APP_COMMON_STOP_SEC_CODE
#include "tpl_memmap.h"
%
#------------------------------------------------------------------------------*

let listState := @[]
foreach resurrect_state in RESURRECT_STATE do
  let key := resurrect_state::NAME
  let listState[key] := INDEX
end foreach

#------------------------------------------------------------------------------*
let RESURRECT_EVENT := exists RESURRECT_EVENT default (@())


%
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
foreach resurrect_transition in RESURRECT_TRANSITION 
  do
  %
CONST(tpl_step, OS_CONST) step_% !resurrect_transition::NAME% = {
  .energy = % !resurrect_transition::ENERGY%
, .to_state = % !listState[resurrect_transition::TO_STATE]%
, .from_state = % !listState[resurrect_transition::FROM_STATE]%
, .entry_point = % !resurrect_transition::ENTRY%%
if OS::RESURRECT_S::EVENT then%
, .resurrect_event = {%
  if [RESURRECT_EVENT length] == 0 then
  %};%
  else
  foreach res_event in RESURRECT_EVENT 
  do
  if exists resurrect_transition::RES_EVENT then
  foreach step_event in resurrect_transition::RES_EVENT do
  if step_event::VALUE == res_event::NAME then
  tab(4)%1%
  else
  tab(4)%0%
  end if
  end foreach
  else
  tab(4)%0%
  end if
  between
  %,%
  after%}%
  end foreach
  end if
  end if
%
};
%
end foreach

%
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
let initial_state
let count_initial := 0

foreach resurrect_state in RESURRECT_STATE do
  if resurrect_state::INITIAL_STATE then
    let initial_state := resurrect_state::NAME
    let count_initial := count_initial+1
    if count_initial > 1 then
     error resurrect_state::INITIAL_STATE : "More than one initial state"
    end if
  end if
  
end foreach

%

/**
 * @internal
 *
 * tpl_kern_resurrect gather informations on the current step and
 * the state
 */
VAR(tpl_kern_resurrect_state, OS_VAR) tpl_kern_resurrect =
{
  NULL,                      /* no elected step   */
  % !listState[initial_state]%,                         /* current state is STATE with INITIAL_STATE = TRUE */%
  if OS::RESURRECT_S::EVENT then
  %
  0,                        /* Events for choice of next step */%
  end if
%  
};

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%

foreach resurrect_state in RESURRECT_STATE do
      %
CONSTP2VAR(tpl_step, AUTOMATIC, OS_APPL_DATA) step_from_state_%!resurrect_state::NAME% [%!OS::RESURRECT_S::ENERGY_LEVEL%] = {
%
      let transitionListEnergy := @()
      foreach resurrect_transition in RESURRECT_TRANSITION do
        if resurrect_state::NAME == resurrect_transition::FROM_STATE then
         let transitionListEnergy += resurrect_transition
         end if
      end foreach
      sort transitionListEnergy by ENERGY >
      foreach item in transitionListEnergy do
      %&step_% !item::NAME
      between
      %,
%
      after
      if [transitionListEnergy length] < OS::RESURRECT_S::ENERGY_LEVEL then
       let null_count := OS::RESURRECT_S::ENERGY_LEVEL - [transitionListEnergy length]
       loop cnt from 1 to null_count step 1 do
         %
, NULL%
        end loop
      end if
      %};
%
      end foreach
end foreach

foreach resurrect_state in RESURRECT_STATE
before
%
CONSTP2CONST(tpl_step_ref, AUTOMATIC, OS_APPL_DATA) tpl_step_state [RESURRECT_STATE_COUNT] = {
%
do
%step_from_state_%!resurrect_state::NAME
between
%,
%
after
%
};
%
end foreach
%
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
end if
